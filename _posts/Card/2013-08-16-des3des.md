---
layout:     post
title:      DES与3DES算法
category: Card
description: 对称算法
---
DES与3DES都是对称算法，即加密和解密分别使用同样的密钥。

从密钥长度来看，DES使用的为8字节（64bits）的密钥，而3DES则使用的是16字节或者24字节的密钥；这两种算法加密得到的数据也与明文长度一致。


**DES算法：** 

DES加密：

一般DES加密算法的参数至少有三个：SourceData、Key、Result，key须为8字节，SourceData须为8的倍数，否则需要补位（通常情况下补00）然后分成每组8字节，分别对每组数据加密即可。

对于Key，DES算法用的只有56bits，每一字节的最低位为奇偶校验位，保证每字节的1为奇数位。

首先需要对按照pc_1对密钥变换：

> <pre>pc_1[] =    {
 57,49,41,33,25,17,9 ,
 1 ,58,50,42,34,26,18,
 10,2 ,59,51,43,35,27,
 19,11,3 ,60,52,44,36,
 63,55,47,39,31,23,15,
 7 ,62,54,46,38,30,22,
 14,6 ,61,53,45,37,29,
 21,13,5 ,28,20,12,4
 };</pre>

这个数组中已经去掉了bit8、bit16、bit24等奇偶校验位；此数组的意思为将原来的key按照bit57、bit49、bit33…依次重新排列成56bits形式的（也可称之为换位）。

为了方便需要先将key转换成bit形式：

<pre>temp=(key[i]&lt;&lt;j)&0x80;
 if(temp)    Key_bit[i*8+j]=0x01;
 else        Key_bit[i*8+j]=0x00;</pre>

再重新排列：for(i=0;i<56;i++)        pc\_1t[i]=Key\_bit[pc_1[i]-1];

换位后再进行循环左移（注意是循环左移，不是左移），共进行16次，移位规则如下：第1、2、9、16次左移一位，其余12次左移两位，每次移位后需要将其按照pc_2换位，最后变为48bits。

<pre>sht[]  =  { 1 ,1 ,2 ,2 ,2 ,2 ,2 ,2 , 1 ,2 ,2 ,2 ,2 ,2 ,2 ,1 };</pre>

<pre>pc_2[] =    {
 14,17,11,24,1 ,5 ,
 3 ,28,15,6 ,21,10,
 23,19,12,4 ,26,8 ,
 16,7 ,27,20,13,2 ,
 41,52,31,37,47,55,
 30,40,51,45,33,48,
 44,49,39,56,34,53,
 46,42,50,36,29,32
 };</pre>

<pre>for(k=0;k&lt;16;k++)
 {
  for(i=0;i&lt;sht[k];i++)
  {
    temp=pc_1t[0];
    for(j=0;j&lt;28;j++)
      if(j==27)    pc_1t[j]=temp;
      else        pc_1t[j]=pc_1t[j+1];

    temp=pc_1t[28];
    for(j=28;j&lt;56;j++)
      if(j==55)    pc_1t[j]=temp;
      else        pc_1t[j]=pc_1t[j+1];
  }
  for(i=0;i&lt;48;i++)
    Childkey[k][i]=pc_1t[pc_2[i]-1];
}</pre>

循环移位结束后，得到16组密钥Childkey\[k\]\[i\]。

密钥可以先告一段落了，再来看看数据SourceData:SourceData若不是8字节，需要进行补位分段加密。

假设SourceData为8字节，按照ip进行换位得到ipt

<pre>ip[]=
 {
 58,50,42,34,26,18,10,2,
 60,52,44,36,28,20,12,4,
 62,54,46,38,30,22,14,6,
 64,56,48,40,32,24,16,8,
 57,49,41,33,25,17,9 ,1,
 59,51,43,35,27,19,11,3,
 61,53,45,37,29,21,13,5,
 63,55,47,39,31,23,15,7
 };</pre>

<pre>for(i=0;i&lt;64;i++)    ipt[i]=src_bit[ip[i]-1];</pre>

<span style="color: #ff0000;"><strong>『』</strong>里的内容循环16次</span>

**<span style="color: #ff0000;">『</span>**

将ipt分成左右两部分即ipt\_l与ipt\_r，ipt\_l不变，将ipt\_r按e扩充为48位得到et：

<pre>e[] =  {
 32,1 ,2 ,3 ,4 ,5 ,
 4 ,5 ,6 ,7 ,8 ,9 ,
 8, 9 ,10,11,12,13,
 12,13,14,15,16,17,
 16,17,18,19,20,21,
 20,21,22,23,24,25,
 24,25,26,27,28,29,
 28,29,30,31,32,1
 };</pre>

<pre>for(i=0;i&lt;48;i++)    et[i]=r[e[i]-1];</pre>

然后再将et\[i]与ChildKey[k\]\[i\]异或得到新的48bits的et（此处k从0开始，循环一次加1）。

<pre>for(i=0;i&lt;48;i++)    et[i]=et[i]^ChildKey[k][i];</pre>

接着需要将et压缩回32bits，

将异或运算得到的48位结果数据et分成8个6bits的块，将每一块通过对应的一个si[i]产生一个4位的输出.
  
其具体置换过程为：
  
将6位输入中的第1位和第6位取出来形成一个2位的二进制数x，将其转化为十进制作为行数，然后将中间4位构成另一个二进制数y，将其转化为十进制作为列数，然后查出相应si的x行y列所对应的整数，将该整数置换为一个4位的二进制数。例如，假设输入数据中的第一个6位数字块为010111，则需要通过查si[1]，先取出010111的第1位和第6位，得x＝01，其对应的十进制数为1；然后取出中间的4位1011，得y＝1011，其对应的十进制数为11，在si[1]盒中，第1行第11列的整数为11，将其转换为二进制为1011，则输出1011,即用4位的1011代替6位的010111。将8个6位数据的置换结果连在一起，形成一个32位的输出pt2。

<pre>si[8][64] =
 {(第0列)                                               (第15列)
 {14,4 ,13,1 ,2 ,15,11,8 ,3 ,10,6 ,12,5 ,9 ,0 ,7 ,   (第0行)
 0 ,15,7 ,4 ,14,2 ,13,1 ,10,6 ,12,11,9 ,5 ,3 ,8 ,     (第1行)
 4 ,1 ,14,8 ,13,6 ,2 ,11,15,12,9 ,7 ,3 ,10,5 ,0 ,     (第2行)
 15,12,8 ,2 ,4 ,9 ,1 ,7 ,5 ,11,3 ,14,10,0 ,6 ,13},    (第3行)</pre>

<pre>{15,1 ,8 ,14,6 ,11,3 ,4 ,9 ,7 ,2 ,13,12,0 ,5 ,10,     (第0行)
 3, 13,4 ,7 ,15,2 ,8 ,14,12,0 ,1 ,10,6 ,9 ,11,5 ,     (第1行)
 0, 14,7 ,11,10,4 ,13,1 ,5 ,8 ,12,6 ,9 ,3 ,2 ,15,
 13,8 ,10,1 ,3 ,15,4 ,2 ,11,6 ,7 ,12,0 ,5 ,14,9 },</pre>

<pre>{10,0 ,9 ,14,6 ,3 ,15,5 ,1 ,13,12,7 ,11,4 ,2 ,8 ,
 13,7 ,0 ,9 ,3 ,4 ,6 ,10,2 ,8 ,5 ,14,12,11,15,1 ,
 13,6 ,4 ,9 ,8 ,15,3 ,0 ,11,1 ,2 ,12,5 ,10,14,7 ,
 1 ,10,13,0 ,6 ,9 ,8 ,7 ,4 ,15,14,3 ,11,5 ,2 ,12},</pre>

<pre>{7 ,13,14,3 ,0 ,6 ,9 ,10,1 ,2 ,8 ,5 ,11,12,4 ,15,
 13,8 ,11,5 ,6 ,15,0 ,3 ,4 ,7 ,2 ,12,1 ,10,14,9 ,
 10,6 ,9 ,0 ,12,11,7 ,13,15,1 ,3 ,14,5 ,2 ,8 ,4 ,
 3 ,15,0 ,6 ,10,1 ,13,8 ,9 ,4 ,5 ,11,12,7 ,2 ,14},</pre>

<pre>{2 ,12,4 ,1 ,7 ,10,11,6 ,8 ,5 ,3 ,15,13,0 ,14,9 ,
 14,11,2 ,12,4 ,7 ,13,1 ,5 ,0 ,15,10,3 ,9 ,8 ,6,
 4 ,2 ,1 ,11,10,13,7 ,8 ,15,9 ,12,5 ,6 ,3 ,0 ,14,
 11,8 ,12,7 ,1 ,14,2 ,13,6 ,15,0 ,9 ,10,4 ,5 ,3 },</pre>

<pre>{12,1 ,10,15,9 ,2 ,6 ,8 ,0 ,13,3 ,4 ,14,7 ,5 ,11,
 10,15,4 ,2 ,7 ,12,9 ,5 ,6 ,1 ,13,14,0 ,11,3 ,8 ,
 9 ,14,15,5 ,2 ,8 ,12,3 ,7 ,0 ,4 ,10,1 ,13,11,6 ,
 4 ,3 ,2 ,12,9 ,5 ,15,10,11,14,1 ,7 ,6 ,0 ,8 ,13},</pre>

<pre>{4 ,11,2 ,14,15,0 ,8 ,13,3 ,12,9 ,7 ,5 ,10,6 ,1 ,
 13,0 ,11,7 ,4 ,9 ,1 ,10,14,3 ,5 ,12,2 ,15,8 ,6 ,
 1 ,4 ,11,13,12,3 ,7 ,14,10,15,6 ,8 ,0 ,5 ,9 ,2 ,
 6 ,11,13,8 ,1 ,4 ,10,7 ,9 ,5 ,0 ,15,14,2 ,3 ,12},</pre>

<pre>{13,2 ,8 ,4 ,6 ,15,11,1 ,10,9 ,3 ,14,5 ,0 ,12,7 ,
 1 ,15,13,8 ,10,3 ,7 ,4 ,12,5 ,6 ,11,0 ,14,9 ,2 ,
 7 ,11,4 ,1 ,9 ,12,14,2 ,0 ,6 ,10,13,15,3 ,5 ,8 ,
 2 ,1 ,14,7 ,4 ,10,8 ,13,15,12,9 ,0 ,3 ,5 ,6 ,11}
 };</pre>

将pt2，按p重新排位

<pre>p[]=
 {
 16,7 ,20,21,
 29,12,28,17,
 1 ,15,23,26,
 5 ,18,31,10,
 2 ,8 ,24,14,
 32,27,3 ,9,
 19,13,30,6,
 22,11,4 ,25
 };</pre>

<pre>for(i=0;i&lt;32;i++)    pt2[i]=pt1[p[i]-1];</pre>

然后将ip\_l与pt2异或得到的新值给ip\_r,pt2的值给ip\_l,这样就得到了新的ip\_r与ip_l

<span style="color: #ff0000;"><strong>』</strong></span>

用第16次循环得到的ip\_r与ip\_l组成64位的数据Result,按照fp重新排位即得到最终加密后的数据。

<pre>fp[] =
 {
 40,8,48,16,56,24,64,32,
 39,7,47,15,55,23,63,31,
 38,6,46,14,54,22,62,30,
 37,5,45,13,53,21,61,29,
 36,4,44,12,52,20,60,28,
 35,3,43,11,51,19,59,27,
 34,2,42,10,50,18,58,26,
 33,1,41, 9,49,17,57,25
 };</pre>

DES解密：

与加密唯一不同的是，在16次循环时，et\[i]与ChildKey[k\]\[i\]异或得到新的48bits的et（此处k从15开始，循环一次减1）。


**3DES算法：**

若key为24字节，则key = key1 || key2 || key3   (key1、key2、key3均为8字节)

若key为16字节，则则key = key1 || key2 ( key1、key2均为8字节，令key3 = key1 )


3DES加密：

先用key1进行DES加密，再用key2进行DES解密，最后用key3进行DES加密.

3DES解密：

先用key3进行DES解密，再用key2进行DES加密，最后用key1进行DES解密.
